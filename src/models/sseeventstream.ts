/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import { ClosedEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import { ToolName, ToolName$inboundSchema } from "./toolname.js";

export type SSESessionDeletedEventData = {
  /**
   * ID of the deleted session
   */
  sessionId: string;
  /**
   * Event type
   */
  type: string;
};

/**
 * Base SSE event with standard fields
 */
export type SSESessionDeletedEvent = {
  /**
   * Event type identifier
   */
  event: "session_deleted";
  /**
   * Unique sequential event identifier for ordering and reconnection
   */
  id: string;
  /**
   * Client retry interval in milliseconds
   */
  retry?: number | undefined;
  data: SSESessionDeletedEventData;
};

export type SSESessionCreatedEventData = {
  /**
   * Unix timestamp when the session was created
   */
  createdAt: number;
  /**
   * ID of the newly created session
   */
  sessionId: string;
  /**
   * Title of the newly created session
   */
  title: string;
  /**
   * Event type
   */
  type: string;
};

/**
 * Base SSE event with standard fields
 */
export type SSESessionCreatedEvent = {
  /**
   * Event type identifier
   */
  event: "session_created";
  /**
   * Unique sequential event identifier for ordering and reconnection
   */
  id: string;
  /**
   * Client retry interval in milliseconds
   */
  retry?: number | undefined;
  data: SSESessionCreatedEventData;
};

export type SSEUserMessageCreatedEventData = {
  /**
   * Content of the user message
   */
  content: string;
  /**
   * ID of the created user message
   */
  messageId: string;
  /**
   * ID of the parent tool call that spawned this subagent (for nested events)
   */
  parentToolCallId?: string | undefined;
  /**
   * User message created event type
   */
  type: string;
};

/**
 * Base SSE event with standard fields
 */
export type SSEUserMessageCreatedEvent = {
  /**
   * Event type identifier
   */
  event: "user_message_created";
  /**
   * Unique sequential event identifier for ordering and reconnection
   */
  id: string;
  /**
   * Client retry interval in milliseconds
   */
  retry?: number | undefined;
  data: SSEUserMessageCreatedEventData;
};

/**
 * Type of notification
 */
export const NotificationType = {
  Info: "info",
  Warning: "warning",
  Error: "error",
  Question: "question",
} as const;
/**
 * Type of notification
 */
export type NotificationType = ClosedEnum<typeof NotificationType>;

/**
 * Expected response type from user
 */
export const ResponseType = {
  Acknowledge: "acknowledge",
  Text: "text",
  Choice: "choice",
} as const;
/**
 * Expected response type from user
 */
export type ResponseType = ClosedEnum<typeof ResponseType>;

export type SSENotificationEventData = {
  /**
   * Available choices (required when responseType is 'choice')
   */
  choices?: Array<string> | undefined;
  /**
   * Unix timestamp when notification was created
   */
  createdAt: number;
  /**
   * Notification identifier
   */
  id: string;
  /**
   * Notification message content
   */
  message: string;
  /**
   * Type of notification
   */
  notificationType: NotificationType;
  /**
   * ID of the parent tool call that spawned this subagent (for nested events)
   */
  parentToolCallId?: string | undefined;
  /**
   * Expected response type from user
   */
  responseType: ResponseType;
  /**
   * Session identifier for the notification
   */
  sessionId: string;
  /**
   * Timeout in seconds for user response
   */
  timeout: number;
  /**
   * Notification title
   */
  title: string;
  /**
   * Notification event type
   */
  type: string;
};

/**
 * Base SSE event with standard fields
 */
export type SSENotificationEvent = {
  /**
   * Event type identifier
   */
  event: "notification";
  /**
   * Unique sequential event identifier for ordering and reconnection
   */
  id: string;
  /**
   * Client retry interval in milliseconds
   */
  retry?: number | undefined;
  data: SSENotificationEventData;
};

/**
 * Additional parameters for the permission request
 */
export type Params = {};

export type SSEPermissionEventData = {
  /**
   * Requested action description
   */
  action: string;
  /**
   * Human-readable permission description
   */
  description: string;
  /**
   * Permission request identifier
   */
  id: string;
  /**
   * Additional parameters for the permission request
   */
  params?: Params | undefined;
  /**
   * ID of the parent tool call that spawned this subagent (for nested events)
   */
  parentToolCallId?: string | undefined;
  /**
   * File path for permission request
   */
  path?: string | undefined;
  /**
   * Session identifier for the permission request
   */
  sessionId: string;
  /**
   * Tool name - either a core tool or MCP tool following {serverName}_{toolName} pattern
   */
  toolName: ToolName;
  /**
   * Permission event type
   */
  type: string;
};

/**
 * Base SSE event with standard fields
 */
export type SSEPermissionEvent = {
  /**
   * Event type identifier
   */
  event: "permission";
  /**
   * Unique sequential event identifier for ordering and reconnection
   */
  id: string;
  /**
   * Client retry interval in milliseconds
   */
  retry?: number | undefined;
  data: SSEPermissionEventData;
};

export type SSEToolExecutionCompleteEventData = {
  /**
   * ID of the parent tool call that spawned this subagent (for nested events)
   */
  parentToolCallId?: string | undefined;
  /**
   * Final execution progress description
   */
  progress: string;
  /**
   * Indicates if tool execution succeeded
   */
  success: boolean;
  /**
   * Tool call identifier
   */
  toolCallId: string;
  /**
   * Tool name - either a core tool or MCP tool following {serverName}_{toolName} pattern
   */
  toolName: ToolName;
  /**
   * Tool execution complete event type
   */
  type: string;
};

/**
 * Base SSE event with standard fields
 */
export type SSEToolExecutionCompleteEvent = {
  /**
   * Event type identifier
   */
  event: "tool_execution_complete";
  /**
   * Unique sequential event identifier for ordering and reconnection
   */
  id: string;
  /**
   * Client retry interval in milliseconds
   */
  retry?: number | undefined;
  data: SSEToolExecutionCompleteEventData;
};

export type SSEToolExecutionStartEventData = {
  /**
   * ID of the parent tool call that spawned this subagent (for nested events)
   */
  parentToolCallId?: string | undefined;
  /**
   * Execution progress description
   */
  progress: string;
  /**
   * Tool call identifier
   */
  toolCallId: string;
  /**
   * Tool name - either a core tool or MCP tool following {serverName}_{toolName} pattern
   */
  toolName: ToolName;
  /**
   * Tool execution start event type
   */
  type: string;
};

/**
 * Base SSE event with standard fields
 */
export type SSEToolExecutionStartEvent = {
  /**
   * Event type identifier
   */
  event: "tool_execution_start";
  /**
   * Unique sequential event identifier for ordering and reconnection
   */
  id: string;
  /**
   * Client retry interval in milliseconds
   */
  retry?: number | undefined;
  data: SSEToolExecutionStartEventData;
};

export type SSEToolUseParameterDeltaEventData = {
  /**
   * ID of the assistant message this tool parameter delta belongs to
   */
  assistantMessageId?: string | undefined;
  /**
   * Partial JSON parameter delta - may not be parseable until complete
   */
  input: string;
  /**
   * ID of the parent tool call that spawned this subagent (for nested events)
   */
  parentToolCallId?: string | undefined;
  /**
   * Tool call identifier for correlation
   */
  toolCallId: string;
  /**
   * Tool use parameter delta event type
   */
  type: string;
};

/**
 * Base SSE event with standard fields
 */
export type SSEToolUseParameterDeltaEvent = {
  /**
   * Event type identifier
   */
  event: "tool_use_parameter_delta";
  /**
   * Unique sequential event identifier for ordering and reconnection
   */
  id: string;
  /**
   * Client retry interval in milliseconds
   */
  retry?: number | undefined;
  data: SSEToolUseParameterDeltaEventData;
};

export type SSEToolUseParameterStreamingCompleteEventData = {
  /**
   * ID of the assistant message this tool belongs to
   */
  assistantMessageId?: string | undefined;
  /**
   * Tool call identifier
   */
  id: string;
  /**
   * Complete JSON-encoded tool input parameters
   */
  input: string;
  /**
   * Tool name - either a core tool or MCP tool following {serverName}_{toolName} pattern
   */
  name: ToolName;
  /**
   * ID of the parent tool call that spawned this subagent (for nested events)
   */
  parentToolCallId?: string | undefined;
  /**
   * Tool use parameter streaming complete event type
   */
  type: string;
};

/**
 * Base SSE event with standard fields
 */
export type SSEToolUseParameterStreamingCompleteEvent = {
  /**
   * Event type identifier
   */
  event: "tool_use_parameter_streaming_complete";
  /**
   * Unique sequential event identifier for ordering and reconnection
   */
  id: string;
  /**
   * Client retry interval in milliseconds
   */
  retry?: number | undefined;
  data: SSEToolUseParameterStreamingCompleteEventData;
};

export type SSEToolUseStartEventData = {
  /**
   * ID of the assistant message this tool belongs to
   */
  assistantMessageId?: string | undefined;
  /**
   * Tool call identifier
   */
  id: string;
  /**
   * Tool name - either a core tool or MCP tool following {serverName}_{toolName} pattern
   */
  name: ToolName;
  /**
   * ID of the parent tool call that spawned this subagent (for nested events)
   */
  parentToolCallId?: string | undefined;
  /**
   * Tool use start event type
   */
  type: string;
};

/**
 * Base SSE event with standard fields
 */
export type SSEToolUseStartEvent = {
  /**
   * Event type identifier
   */
  event: "tool_use_start";
  /**
   * Unique sequential event identifier for ordering and reconnection
   */
  id: string;
  /**
   * Client retry interval in milliseconds
   */
  retry?: number | undefined;
  data: SSEToolUseStartEventData;
};

export type SSEContentEventData = {
  /**
   * ID of the assistant message this content belongs to
   */
  assistantMessageId?: string | undefined;
  /**
   * Streaming content delta
   */
  content: string;
  /**
   * ID of the parent tool call that spawned this subagent (for nested events)
   */
  parentToolCallId?: string | undefined;
  /**
   * Content event type
   */
  type: string;
};

/**
 * Base SSE event with standard fields
 */
export type SSEContentEvent = {
  /**
   * Event type identifier
   */
  event: "content";
  /**
   * Unique sequential event identifier for ordering and reconnection
   */
  id: string;
  /**
   * Client retry interval in milliseconds
   */
  retry?: number | undefined;
  data: SSEContentEventData;
};

export type SSEThinkingEventData = {
  /**
   * ID of the assistant message this thinking belongs to
   */
  assistantMessageId?: string | undefined;
  /**
   * Thinking or reasoning content
   */
  content: string;
  /**
   * ID of the parent tool call that spawned this subagent (for nested events)
   */
  parentToolCallId?: string | undefined;
  /**
   * Thinking event type
   */
  type: string;
};

/**
 * Base SSE event with standard fields
 */
export type SSEThinkingEvent = {
  /**
   * Event type identifier
   */
  event: "thinking";
  /**
   * Unique sequential event identifier for ordering and reconnection
   */
  id: string;
  /**
   * Client retry interval in milliseconds
   */
  retry?: number | undefined;
  data: SSEThinkingEventData;
};

export type SSECompleteEventData = {
  /**
   * Final response content
   */
  content?: string | undefined;
  /**
   * Indicates message processing completion
   */
  done: boolean;
  /**
   * Completed message identifier
   */
  messageId?: string | undefined;
  /**
   * ID of the parent tool call that spawned this subagent (for nested events)
   */
  parentToolCallId?: string | undefined;
  /**
   * Optional reasoning content
   */
  reasoning?: string | undefined;
  /**
   * Duration of reasoning process in milliseconds
   */
  reasoningDuration?: number | undefined;
  /**
   * Completion type
   */
  type: string;
};

/**
 * Base SSE event with standard fields
 */
export type SSECompleteEvent = {
  /**
   * Event type identifier
   */
  event: "complete";
  /**
   * Unique sequential event identifier for ordering and reconnection
   */
  id: string;
  /**
   * Client retry interval in milliseconds
   */
  retry?: number | undefined;
  data: SSECompleteEventData;
};

export type SSEErrorEventData = {
  /**
   * Current retry attempt number
   */
  attempt?: number | undefined;
  /**
   * Error message description
   */
  error: string;
  /**
   * Maximum number of retry attempts
   */
  maxAttempts?: number | undefined;
  /**
   * ID of the parent tool call that spawned this subagent (for nested events)
   */
  parentToolCallId?: string | undefined;
  /**
   * Milliseconds to wait before retry
   */
  retryAfter?: number | undefined;
  /**
   * Error type classification
   */
  type?: string | undefined;
};

/**
 * Base SSE event with standard fields
 */
export type SSEErrorEvent = {
  /**
   * Event type identifier
   */
  event: "error";
  /**
   * Unique sequential event identifier for ordering and reconnection
   */
  id: string;
  /**
   * Client retry interval in milliseconds
   */
  retry?: number | undefined;
  data: SSEErrorEventData;
};

export type SSEHeartbeatEventData = {
  /**
   * Heartbeat type
   */
  type: string;
};

/**
 * Base SSE event with standard fields
 */
export type SSEHeartbeatEvent = {
  /**
   * Event type identifier
   */
  event: "heartbeat";
  /**
   * Unique sequential event identifier for ordering and reconnection
   */
  id: string;
  /**
   * Client retry interval in milliseconds
   */
  retry?: number | undefined;
  data: SSEHeartbeatEventData;
};

export type SSEConnectedEventData = {
  /**
   * Session identifier for the connected stream
   */
  sessionId: string;
};

/**
 * Base SSE event with standard fields
 */
export type SSEConnectedEvent = {
  /**
   * Event type identifier
   */
  event: "connected";
  /**
   * Unique sequential event identifier for ordering and reconnection
   */
  id: string;
  /**
   * Client retry interval in milliseconds
   */
  retry?: number | undefined;
  data: SSEConnectedEventData;
};

/**
 * Server-Sent Event stream with discriminated event types
 */
export type SSEEventStream =
  | SSECompleteEvent
  | SSEConnectedEvent
  | SSEContentEvent
  | SSEErrorEvent
  | SSEHeartbeatEvent
  | SSENotificationEvent
  | SSEPermissionEvent
  | SSESessionCreatedEvent
  | SSESessionDeletedEvent
  | SSEThinkingEvent
  | SSEToolExecutionCompleteEvent
  | SSEToolExecutionStartEvent
  | SSEToolUseParameterDeltaEvent
  | SSEToolUseParameterStreamingCompleteEvent
  | SSEToolUseStartEvent
  | SSEUserMessageCreatedEvent;

/** @internal */
export const SSESessionDeletedEventData$inboundSchema: z.ZodType<
  SSESessionDeletedEventData,
  z.ZodTypeDef,
  unknown
> = z.object({
  sessionId: z.string(),
  type: z.string(),
});

export function sseSessionDeletedEventDataFromJSON(
  jsonString: string,
): SafeParseResult<SSESessionDeletedEventData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SSESessionDeletedEventData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SSESessionDeletedEventData' from JSON`,
  );
}

/** @internal */
export const SSESessionDeletedEvent$inboundSchema: z.ZodType<
  SSESessionDeletedEvent,
  z.ZodTypeDef,
  unknown
> = z.object({
  event: z.literal("session_deleted"),
  id: z.string(),
  retry: z.number().int().optional(),
  data: z.string().transform((v, ctx) => {
    try {
      return JSON.parse(v);
    } catch (err) {
      ctx.addIssue({ code: "custom", message: `malformed json: ${err}` });
      return z.NEVER;
    }
  }).pipe(z.lazy(() => SSESessionDeletedEventData$inboundSchema)),
});

export function sseSessionDeletedEventFromJSON(
  jsonString: string,
): SafeParseResult<SSESessionDeletedEvent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SSESessionDeletedEvent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SSESessionDeletedEvent' from JSON`,
  );
}

/** @internal */
export const SSESessionCreatedEventData$inboundSchema: z.ZodType<
  SSESessionCreatedEventData,
  z.ZodTypeDef,
  unknown
> = z.object({
  createdAt: z.number().int(),
  sessionId: z.string(),
  title: z.string(),
  type: z.string(),
});

export function sseSessionCreatedEventDataFromJSON(
  jsonString: string,
): SafeParseResult<SSESessionCreatedEventData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SSESessionCreatedEventData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SSESessionCreatedEventData' from JSON`,
  );
}

/** @internal */
export const SSESessionCreatedEvent$inboundSchema: z.ZodType<
  SSESessionCreatedEvent,
  z.ZodTypeDef,
  unknown
> = z.object({
  event: z.literal("session_created"),
  id: z.string(),
  retry: z.number().int().optional(),
  data: z.string().transform((v, ctx) => {
    try {
      return JSON.parse(v);
    } catch (err) {
      ctx.addIssue({ code: "custom", message: `malformed json: ${err}` });
      return z.NEVER;
    }
  }).pipe(z.lazy(() => SSESessionCreatedEventData$inboundSchema)),
});

export function sseSessionCreatedEventFromJSON(
  jsonString: string,
): SafeParseResult<SSESessionCreatedEvent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SSESessionCreatedEvent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SSESessionCreatedEvent' from JSON`,
  );
}

/** @internal */
export const SSEUserMessageCreatedEventData$inboundSchema: z.ZodType<
  SSEUserMessageCreatedEventData,
  z.ZodTypeDef,
  unknown
> = z.object({
  content: z.string(),
  messageId: z.string(),
  parentToolCallId: z.string().optional(),
  type: z.string(),
});

export function sseUserMessageCreatedEventDataFromJSON(
  jsonString: string,
): SafeParseResult<SSEUserMessageCreatedEventData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SSEUserMessageCreatedEventData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SSEUserMessageCreatedEventData' from JSON`,
  );
}

/** @internal */
export const SSEUserMessageCreatedEvent$inboundSchema: z.ZodType<
  SSEUserMessageCreatedEvent,
  z.ZodTypeDef,
  unknown
> = z.object({
  event: z.literal("user_message_created"),
  id: z.string(),
  retry: z.number().int().optional(),
  data: z.string().transform((v, ctx) => {
    try {
      return JSON.parse(v);
    } catch (err) {
      ctx.addIssue({ code: "custom", message: `malformed json: ${err}` });
      return z.NEVER;
    }
  }).pipe(z.lazy(() => SSEUserMessageCreatedEventData$inboundSchema)),
});

export function sseUserMessageCreatedEventFromJSON(
  jsonString: string,
): SafeParseResult<SSEUserMessageCreatedEvent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SSEUserMessageCreatedEvent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SSEUserMessageCreatedEvent' from JSON`,
  );
}

/** @internal */
export const NotificationType$inboundSchema: z.ZodNativeEnum<
  typeof NotificationType
> = z.nativeEnum(NotificationType);

/** @internal */
export const ResponseType$inboundSchema: z.ZodNativeEnum<typeof ResponseType> =
  z.nativeEnum(ResponseType);

/** @internal */
export const SSENotificationEventData$inboundSchema: z.ZodType<
  SSENotificationEventData,
  z.ZodTypeDef,
  unknown
> = z.object({
  choices: z.array(z.string()).optional(),
  createdAt: z.number().int(),
  id: z.string(),
  message: z.string(),
  notificationType: NotificationType$inboundSchema,
  parentToolCallId: z.string().optional(),
  responseType: ResponseType$inboundSchema,
  sessionId: z.string(),
  timeout: z.number().int(),
  title: z.string(),
  type: z.string(),
});

export function sseNotificationEventDataFromJSON(
  jsonString: string,
): SafeParseResult<SSENotificationEventData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SSENotificationEventData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SSENotificationEventData' from JSON`,
  );
}

/** @internal */
export const SSENotificationEvent$inboundSchema: z.ZodType<
  SSENotificationEvent,
  z.ZodTypeDef,
  unknown
> = z.object({
  event: z.literal("notification"),
  id: z.string(),
  retry: z.number().int().optional(),
  data: z.string().transform((v, ctx) => {
    try {
      return JSON.parse(v);
    } catch (err) {
      ctx.addIssue({ code: "custom", message: `malformed json: ${err}` });
      return z.NEVER;
    }
  }).pipe(z.lazy(() => SSENotificationEventData$inboundSchema)),
});

export function sseNotificationEventFromJSON(
  jsonString: string,
): SafeParseResult<SSENotificationEvent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SSENotificationEvent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SSENotificationEvent' from JSON`,
  );
}

/** @internal */
export const Params$inboundSchema: z.ZodType<Params, z.ZodTypeDef, unknown> = z
  .object({});

export function paramsFromJSON(
  jsonString: string,
): SafeParseResult<Params, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Params$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Params' from JSON`,
  );
}

/** @internal */
export const SSEPermissionEventData$inboundSchema: z.ZodType<
  SSEPermissionEventData,
  z.ZodTypeDef,
  unknown
> = z.object({
  action: z.string(),
  description: z.string(),
  id: z.string(),
  params: z.lazy(() => Params$inboundSchema).optional(),
  parentToolCallId: z.string().optional(),
  path: z.string().optional(),
  sessionId: z.string(),
  toolName: ToolName$inboundSchema,
  type: z.string(),
});

export function ssePermissionEventDataFromJSON(
  jsonString: string,
): SafeParseResult<SSEPermissionEventData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SSEPermissionEventData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SSEPermissionEventData' from JSON`,
  );
}

/** @internal */
export const SSEPermissionEvent$inboundSchema: z.ZodType<
  SSEPermissionEvent,
  z.ZodTypeDef,
  unknown
> = z.object({
  event: z.literal("permission"),
  id: z.string(),
  retry: z.number().int().optional(),
  data: z.string().transform((v, ctx) => {
    try {
      return JSON.parse(v);
    } catch (err) {
      ctx.addIssue({ code: "custom", message: `malformed json: ${err}` });
      return z.NEVER;
    }
  }).pipe(z.lazy(() => SSEPermissionEventData$inboundSchema)),
});

export function ssePermissionEventFromJSON(
  jsonString: string,
): SafeParseResult<SSEPermissionEvent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SSEPermissionEvent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SSEPermissionEvent' from JSON`,
  );
}

/** @internal */
export const SSEToolExecutionCompleteEventData$inboundSchema: z.ZodType<
  SSEToolExecutionCompleteEventData,
  z.ZodTypeDef,
  unknown
> = z.object({
  parentToolCallId: z.string().optional(),
  progress: z.string(),
  success: z.boolean(),
  toolCallId: z.string(),
  toolName: ToolName$inboundSchema,
  type: z.string(),
});

export function sseToolExecutionCompleteEventDataFromJSON(
  jsonString: string,
): SafeParseResult<SSEToolExecutionCompleteEventData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SSEToolExecutionCompleteEventData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SSEToolExecutionCompleteEventData' from JSON`,
  );
}

/** @internal */
export const SSEToolExecutionCompleteEvent$inboundSchema: z.ZodType<
  SSEToolExecutionCompleteEvent,
  z.ZodTypeDef,
  unknown
> = z.object({
  event: z.literal("tool_execution_complete"),
  id: z.string(),
  retry: z.number().int().optional(),
  data: z.string().transform((v, ctx) => {
    try {
      return JSON.parse(v);
    } catch (err) {
      ctx.addIssue({ code: "custom", message: `malformed json: ${err}` });
      return z.NEVER;
    }
  }).pipe(z.lazy(() => SSEToolExecutionCompleteEventData$inboundSchema)),
});

export function sseToolExecutionCompleteEventFromJSON(
  jsonString: string,
): SafeParseResult<SSEToolExecutionCompleteEvent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SSEToolExecutionCompleteEvent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SSEToolExecutionCompleteEvent' from JSON`,
  );
}

/** @internal */
export const SSEToolExecutionStartEventData$inboundSchema: z.ZodType<
  SSEToolExecutionStartEventData,
  z.ZodTypeDef,
  unknown
> = z.object({
  parentToolCallId: z.string().optional(),
  progress: z.string(),
  toolCallId: z.string(),
  toolName: ToolName$inboundSchema,
  type: z.string(),
});

export function sseToolExecutionStartEventDataFromJSON(
  jsonString: string,
): SafeParseResult<SSEToolExecutionStartEventData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SSEToolExecutionStartEventData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SSEToolExecutionStartEventData' from JSON`,
  );
}

/** @internal */
export const SSEToolExecutionStartEvent$inboundSchema: z.ZodType<
  SSEToolExecutionStartEvent,
  z.ZodTypeDef,
  unknown
> = z.object({
  event: z.literal("tool_execution_start"),
  id: z.string(),
  retry: z.number().int().optional(),
  data: z.string().transform((v, ctx) => {
    try {
      return JSON.parse(v);
    } catch (err) {
      ctx.addIssue({ code: "custom", message: `malformed json: ${err}` });
      return z.NEVER;
    }
  }).pipe(z.lazy(() => SSEToolExecutionStartEventData$inboundSchema)),
});

export function sseToolExecutionStartEventFromJSON(
  jsonString: string,
): SafeParseResult<SSEToolExecutionStartEvent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SSEToolExecutionStartEvent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SSEToolExecutionStartEvent' from JSON`,
  );
}

/** @internal */
export const SSEToolUseParameterDeltaEventData$inboundSchema: z.ZodType<
  SSEToolUseParameterDeltaEventData,
  z.ZodTypeDef,
  unknown
> = z.object({
  assistantMessageId: z.string().optional(),
  input: z.string(),
  parentToolCallId: z.string().optional(),
  toolCallId: z.string(),
  type: z.string(),
});

export function sseToolUseParameterDeltaEventDataFromJSON(
  jsonString: string,
): SafeParseResult<SSEToolUseParameterDeltaEventData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SSEToolUseParameterDeltaEventData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SSEToolUseParameterDeltaEventData' from JSON`,
  );
}

/** @internal */
export const SSEToolUseParameterDeltaEvent$inboundSchema: z.ZodType<
  SSEToolUseParameterDeltaEvent,
  z.ZodTypeDef,
  unknown
> = z.object({
  event: z.literal("tool_use_parameter_delta"),
  id: z.string(),
  retry: z.number().int().optional(),
  data: z.string().transform((v, ctx) => {
    try {
      return JSON.parse(v);
    } catch (err) {
      ctx.addIssue({ code: "custom", message: `malformed json: ${err}` });
      return z.NEVER;
    }
  }).pipe(z.lazy(() => SSEToolUseParameterDeltaEventData$inboundSchema)),
});

export function sseToolUseParameterDeltaEventFromJSON(
  jsonString: string,
): SafeParseResult<SSEToolUseParameterDeltaEvent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SSEToolUseParameterDeltaEvent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SSEToolUseParameterDeltaEvent' from JSON`,
  );
}

/** @internal */
export const SSEToolUseParameterStreamingCompleteEventData$inboundSchema:
  z.ZodType<
    SSEToolUseParameterStreamingCompleteEventData,
    z.ZodTypeDef,
    unknown
  > = z.object({
    assistantMessageId: z.string().optional(),
    id: z.string(),
    input: z.string(),
    name: ToolName$inboundSchema,
    parentToolCallId: z.string().optional(),
    type: z.string(),
  });

export function sseToolUseParameterStreamingCompleteEventDataFromJSON(
  jsonString: string,
): SafeParseResult<
  SSEToolUseParameterStreamingCompleteEventData,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      SSEToolUseParameterStreamingCompleteEventData$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'SSEToolUseParameterStreamingCompleteEventData' from JSON`,
  );
}

/** @internal */
export const SSEToolUseParameterStreamingCompleteEvent$inboundSchema: z.ZodType<
  SSEToolUseParameterStreamingCompleteEvent,
  z.ZodTypeDef,
  unknown
> = z.object({
  event: z.literal("tool_use_parameter_streaming_complete"),
  id: z.string(),
  retry: z.number().int().optional(),
  data: z.string().transform((v, ctx) => {
    try {
      return JSON.parse(v);
    } catch (err) {
      ctx.addIssue({ code: "custom", message: `malformed json: ${err}` });
      return z.NEVER;
    }
  }).pipe(
    z.lazy(() => SSEToolUseParameterStreamingCompleteEventData$inboundSchema),
  ),
});

export function sseToolUseParameterStreamingCompleteEventFromJSON(
  jsonString: string,
): SafeParseResult<
  SSEToolUseParameterStreamingCompleteEvent,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      SSEToolUseParameterStreamingCompleteEvent$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'SSEToolUseParameterStreamingCompleteEvent' from JSON`,
  );
}

/** @internal */
export const SSEToolUseStartEventData$inboundSchema: z.ZodType<
  SSEToolUseStartEventData,
  z.ZodTypeDef,
  unknown
> = z.object({
  assistantMessageId: z.string().optional(),
  id: z.string(),
  name: ToolName$inboundSchema,
  parentToolCallId: z.string().optional(),
  type: z.string(),
});

export function sseToolUseStartEventDataFromJSON(
  jsonString: string,
): SafeParseResult<SSEToolUseStartEventData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SSEToolUseStartEventData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SSEToolUseStartEventData' from JSON`,
  );
}

/** @internal */
export const SSEToolUseStartEvent$inboundSchema: z.ZodType<
  SSEToolUseStartEvent,
  z.ZodTypeDef,
  unknown
> = z.object({
  event: z.literal("tool_use_start"),
  id: z.string(),
  retry: z.number().int().optional(),
  data: z.string().transform((v, ctx) => {
    try {
      return JSON.parse(v);
    } catch (err) {
      ctx.addIssue({ code: "custom", message: `malformed json: ${err}` });
      return z.NEVER;
    }
  }).pipe(z.lazy(() => SSEToolUseStartEventData$inboundSchema)),
});

export function sseToolUseStartEventFromJSON(
  jsonString: string,
): SafeParseResult<SSEToolUseStartEvent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SSEToolUseStartEvent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SSEToolUseStartEvent' from JSON`,
  );
}

/** @internal */
export const SSEContentEventData$inboundSchema: z.ZodType<
  SSEContentEventData,
  z.ZodTypeDef,
  unknown
> = z.object({
  assistantMessageId: z.string().optional(),
  content: z.string(),
  parentToolCallId: z.string().optional(),
  type: z.string(),
});

export function sseContentEventDataFromJSON(
  jsonString: string,
): SafeParseResult<SSEContentEventData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SSEContentEventData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SSEContentEventData' from JSON`,
  );
}

/** @internal */
export const SSEContentEvent$inboundSchema: z.ZodType<
  SSEContentEvent,
  z.ZodTypeDef,
  unknown
> = z.object({
  event: z.literal("content"),
  id: z.string(),
  retry: z.number().int().optional(),
  data: z.string().transform((v, ctx) => {
    try {
      return JSON.parse(v);
    } catch (err) {
      ctx.addIssue({ code: "custom", message: `malformed json: ${err}` });
      return z.NEVER;
    }
  }).pipe(z.lazy(() => SSEContentEventData$inboundSchema)),
});

export function sseContentEventFromJSON(
  jsonString: string,
): SafeParseResult<SSEContentEvent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SSEContentEvent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SSEContentEvent' from JSON`,
  );
}

/** @internal */
export const SSEThinkingEventData$inboundSchema: z.ZodType<
  SSEThinkingEventData,
  z.ZodTypeDef,
  unknown
> = z.object({
  assistantMessageId: z.string().optional(),
  content: z.string(),
  parentToolCallId: z.string().optional(),
  type: z.string(),
});

export function sseThinkingEventDataFromJSON(
  jsonString: string,
): SafeParseResult<SSEThinkingEventData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SSEThinkingEventData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SSEThinkingEventData' from JSON`,
  );
}

/** @internal */
export const SSEThinkingEvent$inboundSchema: z.ZodType<
  SSEThinkingEvent,
  z.ZodTypeDef,
  unknown
> = z.object({
  event: z.literal("thinking"),
  id: z.string(),
  retry: z.number().int().optional(),
  data: z.string().transform((v, ctx) => {
    try {
      return JSON.parse(v);
    } catch (err) {
      ctx.addIssue({ code: "custom", message: `malformed json: ${err}` });
      return z.NEVER;
    }
  }).pipe(z.lazy(() => SSEThinkingEventData$inboundSchema)),
});

export function sseThinkingEventFromJSON(
  jsonString: string,
): SafeParseResult<SSEThinkingEvent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SSEThinkingEvent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SSEThinkingEvent' from JSON`,
  );
}

/** @internal */
export const SSECompleteEventData$inboundSchema: z.ZodType<
  SSECompleteEventData,
  z.ZodTypeDef,
  unknown
> = z.object({
  content: z.string().optional(),
  done: z.boolean(),
  messageId: z.string().optional(),
  parentToolCallId: z.string().optional(),
  reasoning: z.string().optional(),
  reasoningDuration: z.number().int().optional(),
  type: z.string(),
});

export function sseCompleteEventDataFromJSON(
  jsonString: string,
): SafeParseResult<SSECompleteEventData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SSECompleteEventData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SSECompleteEventData' from JSON`,
  );
}

/** @internal */
export const SSECompleteEvent$inboundSchema: z.ZodType<
  SSECompleteEvent,
  z.ZodTypeDef,
  unknown
> = z.object({
  event: z.literal("complete"),
  id: z.string(),
  retry: z.number().int().optional(),
  data: z.string().transform((v, ctx) => {
    try {
      return JSON.parse(v);
    } catch (err) {
      ctx.addIssue({ code: "custom", message: `malformed json: ${err}` });
      return z.NEVER;
    }
  }).pipe(z.lazy(() => SSECompleteEventData$inboundSchema)),
});

export function sseCompleteEventFromJSON(
  jsonString: string,
): SafeParseResult<SSECompleteEvent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SSECompleteEvent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SSECompleteEvent' from JSON`,
  );
}

/** @internal */
export const SSEErrorEventData$inboundSchema: z.ZodType<
  SSEErrorEventData,
  z.ZodTypeDef,
  unknown
> = z.object({
  attempt: z.number().int().optional(),
  error: z.string(),
  maxAttempts: z.number().int().optional(),
  parentToolCallId: z.string().optional(),
  retryAfter: z.number().int().optional(),
  type: z.string().optional(),
});

export function sseErrorEventDataFromJSON(
  jsonString: string,
): SafeParseResult<SSEErrorEventData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SSEErrorEventData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SSEErrorEventData' from JSON`,
  );
}

/** @internal */
export const SSEErrorEvent$inboundSchema: z.ZodType<
  SSEErrorEvent,
  z.ZodTypeDef,
  unknown
> = z.object({
  event: z.literal("error"),
  id: z.string(),
  retry: z.number().int().optional(),
  data: z.string().transform((v, ctx) => {
    try {
      return JSON.parse(v);
    } catch (err) {
      ctx.addIssue({ code: "custom", message: `malformed json: ${err}` });
      return z.NEVER;
    }
  }).pipe(z.lazy(() => SSEErrorEventData$inboundSchema)),
});

export function sseErrorEventFromJSON(
  jsonString: string,
): SafeParseResult<SSEErrorEvent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SSEErrorEvent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SSEErrorEvent' from JSON`,
  );
}

/** @internal */
export const SSEHeartbeatEventData$inboundSchema: z.ZodType<
  SSEHeartbeatEventData,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.string(),
});

export function sseHeartbeatEventDataFromJSON(
  jsonString: string,
): SafeParseResult<SSEHeartbeatEventData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SSEHeartbeatEventData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SSEHeartbeatEventData' from JSON`,
  );
}

/** @internal */
export const SSEHeartbeatEvent$inboundSchema: z.ZodType<
  SSEHeartbeatEvent,
  z.ZodTypeDef,
  unknown
> = z.object({
  event: z.literal("heartbeat"),
  id: z.string(),
  retry: z.number().int().optional(),
  data: z.string().transform((v, ctx) => {
    try {
      return JSON.parse(v);
    } catch (err) {
      ctx.addIssue({ code: "custom", message: `malformed json: ${err}` });
      return z.NEVER;
    }
  }).pipe(z.lazy(() => SSEHeartbeatEventData$inboundSchema)),
});

export function sseHeartbeatEventFromJSON(
  jsonString: string,
): SafeParseResult<SSEHeartbeatEvent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SSEHeartbeatEvent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SSEHeartbeatEvent' from JSON`,
  );
}

/** @internal */
export const SSEConnectedEventData$inboundSchema: z.ZodType<
  SSEConnectedEventData,
  z.ZodTypeDef,
  unknown
> = z.object({
  sessionId: z.string(),
});

export function sseConnectedEventDataFromJSON(
  jsonString: string,
): SafeParseResult<SSEConnectedEventData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SSEConnectedEventData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SSEConnectedEventData' from JSON`,
  );
}

/** @internal */
export const SSEConnectedEvent$inboundSchema: z.ZodType<
  SSEConnectedEvent,
  z.ZodTypeDef,
  unknown
> = z.object({
  event: z.literal("connected"),
  id: z.string(),
  retry: z.number().int().optional(),
  data: z.string().transform((v, ctx) => {
    try {
      return JSON.parse(v);
    } catch (err) {
      ctx.addIssue({ code: "custom", message: `malformed json: ${err}` });
      return z.NEVER;
    }
  }).pipe(z.lazy(() => SSEConnectedEventData$inboundSchema)),
});

export function sseConnectedEventFromJSON(
  jsonString: string,
): SafeParseResult<SSEConnectedEvent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SSEConnectedEvent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SSEConnectedEvent' from JSON`,
  );
}

/** @internal */
export const SSEEventStream$inboundSchema: z.ZodType<
  SSEEventStream,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => SSECompleteEvent$inboundSchema),
  z.lazy(() => SSEConnectedEvent$inboundSchema),
  z.lazy(() => SSEContentEvent$inboundSchema),
  z.lazy(() => SSEErrorEvent$inboundSchema),
  z.lazy(() => SSEHeartbeatEvent$inboundSchema),
  z.lazy(() => SSENotificationEvent$inboundSchema),
  z.lazy(() => SSEPermissionEvent$inboundSchema),
  z.lazy(() => SSESessionCreatedEvent$inboundSchema),
  z.lazy(() => SSESessionDeletedEvent$inboundSchema),
  z.lazy(() => SSEThinkingEvent$inboundSchema),
  z.lazy(() => SSEToolExecutionCompleteEvent$inboundSchema),
  z.lazy(() => SSEToolExecutionStartEvent$inboundSchema),
  z.lazy(() => SSEToolUseParameterDeltaEvent$inboundSchema),
  z.lazy(() => SSEToolUseParameterStreamingCompleteEvent$inboundSchema),
  z.lazy(() => SSEToolUseStartEvent$inboundSchema),
  z.lazy(() => SSEUserMessageCreatedEvent$inboundSchema),
]);

export function sseEventStreamFromJSON(
  jsonString: string,
): SafeParseResult<SSEEventStream, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SSEEventStream$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SSEEventStream' from JSON`,
  );
}
